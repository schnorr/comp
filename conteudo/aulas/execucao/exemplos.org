# -*- coding: utf-8 -*-
# -*- mode: org -*-
#+startup: beamer overview indent
#+LANGUAGE: pt-br
#+TAGS: noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_SELECT_TAGS: export

#+Title: Exemplos com ILOC
#+Author: Prof. Lucas M. Schnorr (UFRGS)
#+Date: \copyleft

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [xcolor=dvipsnames]
#+OPTIONS:   H:1 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \input{../org-babel.tex}

* Função principal
Entrada
  #+BEGIN_SRC amarela
  int main () { }
  #+END_SRC
#+latex: \vfill
\pause  ILOC
  #+BEGIN_SRC iloc
  loadI 1024 => fp
  loadI 1024 => sp
  loadI 7 => bss
  jumpI => L0
  L0: addI sp, 0 => sp
  halt
  #+END_SRC
+ Segmento de dados depois do segmento de código
+ A pilha começa no endereço 1024
+ Cada linha de código ocupa um único byte
* Variáveis locais na pilha
Entrada
  #+BEGIN_SRC amarela
  int main () { int x; x = 34; }
  #+END_SRC
\pause  ILOC
  #+BEGIN_SRC iloc
  loadI 1024 => fp
  loadI 1024 => sp
  loadI 9 => bss
  jumpI => L0
  L0: addI sp, 4 => sp
  loadI 34 => r0
  storeAI r0 => fp, 0
  halt
  #+END_SRC
* Variáveis globais e locais
Entrada
  #+BEGIN_SRC amarela
  int y; int main () { int x; y = 59; x = 33; }
  #+END_SRC
\pause  ILOC
  #+BEGIN_SRC iloc
  loadI 1024 => fp
  loadI 1024 => sp
  loadI 11 => bss
  jumpI => L0
  L0: addI sp, 4 => sp
  loadI 59 => r0
  storeAI r0 => bss, 0
  loadI 33 => r0
  storeAI r0 => fp, 0
  halt
  #+END_SRC
* Chamada de função
Entrada
  #+BEGIN_SRC amarela
  int f() { return 73; } int main() { int x; x = f(); }
  #+END_SRC
\pause  ILOC
  \tiny
  #+BEGIN_SRC iloc
  loadI 1024 => fp
  loadI 1024 => sp
  loadI 23 => bss
  jumpI => L1
  L0: i2i sp => fp
  addI sp, 16 => sp   //final do epílogo
  loadI 73 => r0      //seq retorno
  storeAI r0 => fp, 12
  loadAI fp, 0 => r0  //obtém end. retorno
  loadAI fp, 4 => r1  //obtém sp salvo
  loadAI fp, 8 => r2  //obtém fp salvo
  store r1 => sp
  store r2 => fp
  jump => r0
  L1: addI sp, 4 => sp
  storeAI 20 => sp, 0 //seq. chamada
  storeAI sp => sp, 4
  storeAI fp => sp, 8
  jumpI => L0
  loadAI sp, 12 => r0
  storeAI r0 => fp, 0
  halt
  #+END_SRC
* Passagem por valor
#+latex: \tiny
#+BEGIN_SRC amarela
int f(int y) { return y; } int main() { int x; x = f(x); }
#+END_SRC

#+BEGIN_SRC asm :tangle exemplo5.iloc
// Programa de entrada
// int foo(int y) { return y; } int main() { int x; x = foo(x); }

// FP: Frame Pointer
// SP: Stack Pointer
// BSS: uninitialized data segment
	
// Inicializa os registradores rfp (FP), rsp (SP), e rbss (BSS)
// FP e SP apontam inicialmente para a base da pilha
// BSS aponta para o início do segmento de dados
loadI 1024 => rfp
loadI 1024 => rsp
loadI 29 => rbss
// O código da função main está em L1, salta para lá	
jumpI => L1
// Início da função foo
L0: i2i rsp => rfp     // Atualiza o rfp (FP)
addI rsp, 20 => rsp    // Atualiza o rsp (SP)
loadAI rfp, 12 => r0   // Obtém o parâmetro
storeAI r0 => rfp, 20  // Salva o parâmetro na variável y
loadAI rfp, 20 => r0   // Salva o valor da variável y em r0
storeAI r0 => rfp, 16  // Registra o valor de retorno
loadAI rfp, 0 => r0    // Obtém end. retorno
loadAI rfp, 4 => r1    // Obtém rsp (SP) salvo
loadAI rfp, 8 => r2    // Obtém rfp (FP) salvo
store r1 => rsp        // Atualiza o rsp (SP)
store r2 => rfp        // Atualiza o rfp (FP)
jump => r0             // Salta para o endereço de retorno
// Início da função main	
L1: addI rsp, 4 => rsp // Reserva espaço para a variável local x
addI rpc,7  => r1      // Calcula o endereço de retorno (7 instruções abaixo)
storeAI r1  => rsp, 0  // Salva o endereço de retorno
storeAI rsp => rsp, 4  // Salva o rsp (SP)
storeAI rfp => rsp, 8  // Salva o rfp (FP)
loadAI  rfp, 0 => r0   // Carrega o valor da variável x em r0
storeAI r0 => rsp, 12  // Empilha o parâmetro
jumpI => L0            // Salta para o início da função chamada
loadAI rsp, 16 => r0   // Retorno da função, carrega o valor de retorno
storeAI r0 => rfp, 0   // Salva o retorno na variável x
#+END_SRC

