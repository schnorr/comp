# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+TITLE: Dúvidas da E3 do Projeto de Compilador
#+Author: Lucas Mello Schnorr
#+Date: schnorr@inf.ufrgs.br
#+Language: pt-br

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, a4paper]
#+LATEX_HEADER: \input{org-babel.tex}

#+OPTIONS: toc:nil title:nil
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* E3 2020/2
** DONE 2021-03-03 D0
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao invés de C?
Precisaríamos mudar o main.c para main.cpp, mas isto facilitaria para
a construção da árvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma árvore com um número arbitrário de filhos em
cada nó. Podemos fazer esta alteração?

R: Pode sim (usar C++), mas não vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as funções em arquivos separados, cpp, que
são chamadas pelo código em C normal como está no main.c.
*** Pergunta #2.1

1) Precisamos colocar tipo nos tokens? Por exemplo: ~%token<valorReal>~
   ~TK_LIT_FLOAT~, ou somente a declaração do ~valor_lexico~ é suficiente?
   Se precisamos, temos como reaproveitar as definições do
   ~valor_lexico~?  Como faríamos isso?

R: Somente a declaração do valor léxico é suficiente, e recomendada de
acordo com a especificação. Nota que somente assim poderemos ter
acesso a uma estrutura genérica que poderá ser tratada independente de
qual é o valor do token por trás. Esse valor do token não será
perdido, temos descritores dentro da estrutura valor léxico que serão
responsáveis por diferenciar os tipos de literais, por exemplo.

*** Pergunta #2.2

2) Qual o tipo de dado de cada elemento da arvore? Seria a estrutura
   que contém número da linha, tipo e valor?

R: Cada nó da árvore deve ser de um tipo estrutura de dados definida
pelo grupo. Tipicamente, usa-se uma estrutura de árvore genérica
n-ária com um campo de usuário, onde nesse campo de usuário o grupo
poderá adicionar informações relativas à AST (tipo do nó, etc).

*** Pergunta #2.3

3) Para construirmos a arvore, pensamos em duas funções:

    - Uma que cria e retorna uma folha e, se a arvore esta vazia,
      atribui à arvore esta folha

    - Uma que recebe dados e filhos, cria um nodo, insere mais um
      filho e coloca a arvore nesse filho, depois atribui à arvore
      este novo nodo

Isto está correto? É assim mesmo para construirmos a árvore?

R: Uma folha é um nó sem filhos, então acho improdutivo ter um nó tipo
folha e um nó tipo intermediário. Conforme descrito na Sec 2.2, acho
que é importante ter funções de criação de nós e adição de filhos. A
construção da árvore em si é feita através das regras do bison. Um
exemplo, como criar a AST para a regra abaixo:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Perceba o uso de $1 e $3 conforme vimos no video bison parte 2.  No
exemplo acima, apenas duas funções foram necessárias (~ast_create~ e
~ast_add_child~). Fica a critério do grupo empregar funções mais
sofisticadas se preferirem.

*** Pergunta #3

 Para representarmos uma expressão ternária na árvore sintática
 abstrata, posso considerar apenas a interrogação (?) como pai e os
 três outros operandos como filhos, ignorando os dois pontos (:)?

R: Pode. Mas veja que na prática, a interrogação e os dois pontos são
um único operador. Inclusive, chamos a atenção para o que está
explicitado na Sec 2.4: "No caso do operador ternário, deve ser
utilizado o nome '?:'.", mas isso apenas na saída. A tua AST pode
conter o tipo que quiser, como ~AST_TERNARY~ ou algo assim.

*** Pergunta #4

 Estou com dificuldade de entender como funciona o processo de
 construção da árvore sintática quando há múltiplas linhas de
 código. Em especial, como fazemos a inserção de folhas e de nodos com
 filhos? Nodos folhas devem ser inseridas onde? Nodos com filhos devem
 tornar-se pais do resto da arvore ou seguir como filhos da raiz? Como
 sabemos qual nodo é pai dos nodos filho?

R: Recomendo fazer um programa completo escrito na nossa linguagem e
executar o nosso compilador da seguinte forma:

#+BEGIN_EXAMPLE
./etapa3 < arquivo_com_programa_com_multiplas_linhas
#+END_EXAMPLE

Para fazer a inserção de nós e filhos, deve-se empregar totalmente os
marcadores especiais do bison para isso, através da adição de código
no final de cada regra gramatical, pois é ele que irá decidir a ordem
que estes códigos serão criados. Por exemplo, para a regra gramatical
que envolve o reconhecimento sintático da soma binária:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Neste caso acima, temos um nó intermediário de soma que tem dois
filhos. Nós criamos um novo nó da nossa AST, com o tipo ~AST_SUM~, e o
atribuímos para $$, que é o marcador especial do bison para se referir
a cabeça da produção gramatical. Em seguida, adicionamos dois filhos,
primeiro o filho $1 e depois o filho $3 que são respectivamente os
dois operandos E do corpo da produção. Veja que esses operandos são
também do não-terminal E, então podemos sem dúvida assumir que os nós
da AST deles já foram criados pela execução de código associado às
outras regras gramaticais (inclusive essa mesma).

*** Pergunta #5

 Para representar a árvore, pensamos numa estrutura onde um nodo
 indica um próximo irmão e um próximo filho, ou seja, é uma árvore
 cujos filhos são listas encadeadas. Isto é permitido?

R: Recomendo a leitura da Sec 2.2 da especificação. Em geral, eu não
recomendo esse tipo de estrutura onde os irmãos estão conectados pois
ela não é natural no contexto de uma AST. Não teremos relação diretas
entre irmãos, apenas entre pai e seus filhos. Se algo preciso ser
feito entre irmãos, é o pai que se ocupará.

** DONE 2021-03-04 D1
*** Pergunta #1

Ficou claro para mim como devo lidar com ~$$~ nas produções, porém ainda
fiquei com uma dúvida: como fazemos para associar ~$$~ com a variável
void* arvore? Além disso, este void eu vou trocar para a minha struct
de nodo, certo? Ficará node* arvore, certo?​

R: A variável global ~arvore~ está definida no arquivo main.c e é
declarada como ~void*~, ou seja, ~arvore~ é um ponteiro para qualquer
coisa. É preferível que sua definição não mude. Para integrar o que
vocês farão com o comportamento imutável do main basta, no parser.y,
declarar a variável ~arvore~ como ~extern~, da seguinte forma:
#+BEGIN_EXAMPLE
extern void *arvore;
#+END_EXAMPLE
E depois, na primeira regra gramatical, ou seja, no primeiro
não-terminal a partir do qual tudo começa (tipicamente ~programa~),
deve-se definir o conteúdo da variável ~arvore~. Para evitar problemas
de compilação, etc, o grupo pode na atribuição forçar um cast. Esse
cast pode ser revertido na implementação das funções ~exporta~ e ~libera~,
cujo protótipo também não deve mudar. Como sabemos que é a mesma
variável que vai e vem, espera-se que não haverão problemas.

*** Pergunta #2

Eu e minha dupla não entendemos muito bem como devemos percorrer a
árvore para printá-la. O senhor poderia nos explicar melhor, por
favor?

R: O percorrimento da árvore deve ser de maneira recursiva. Para
atingir o efeito descrito na Sec 2.4 da especificação, deve-se, ao
chegar um determinado nó da árvore: 1) imprimir o endereço de memória
onde está a estrutura de dados (usando o %p como formatador para o
printf), seguido do seu label (consultem o formato na espec. da E2),
lembrando que o valor do label depende do tipo do nó; 2) para cada
filho (se houver), imprimir, para cada filho, o endereço de memória do
nó que estamos visitando seguido de uma vírgula seguido do endereço de
memória do filho. Feito essa listagem, basta recursivamente chamar a
função exporta para cada filho.

*** Pergunta #3

Na especificação da E3 está escrito que "Devem fazer parte da AST:
[...] Todos os comandos simples da linguagem, salvo o bloco de
comando" . MInha dúvida é: devemos simplesmente ignorar os blocos de
comando ao criar a AST?

R: Sim. Os blocos de comando e a declaração de variáveis sem
inicialização não devem fazer parte da AST. O bloco de comando
continua sendo importante para estruturar sintaticamente o programa,
ou seja, deve fazer parte da sintaxe como na E2.

*** Pergunta #4.1

estou confuso sobre o conteúdo do %union, mesmo tendo lido a seção 2.1
do enunciado várias vezes.

1) O enunciado diz que se sugere usar um campo de nome valor_lexico, e
   que o tipo dele é uma estrutura de dados com 3 campos: número da
   linha, tipo do token e valor do token. Estou com dificuldade de
   visualizar essa estrutura. Minha ideia inicial paraa fazer o %union
   foi essa:

#+BEGIN_EXAMPLE
%union
{
  VALUE *valor_lexico;
}

enum tokenType {
  specialChar, compoundOperator, identifier, literal
};

typedef struct value_struct
{
  int n_line;
  enum tokenType token_type;
  char* tokenValue;
} VALUE;
#+END_EXAMPLE

Teria alguma sugestão para fazer o %union de uma maneira mais simples
(por exemplo, sem o enum)?

----------

R: Nós vimos que a AST (veja aula N5 A0) tem nós intermediários e nós
folha, sendo que estas folhas são frequentemente os tokens obtidos na
entrada. Por essa razão, os tokens que integram as folhas na AST
(tipicamente identificadores e os literais) devem possuir um valor
pois eles integrarão parte da AST. Sendo esta a teoria e, por ser algo
muito frequente a ser implementado, o bison dá um suporte completo
para essa atividade, através do comando %union. Os campos dessa union
são os possíveis "valores" que podem estar associados aos tokens e aos
não-terminais. Em nosso projeto, o comando %union do bison normalmente
ter dois campos, como abaixo, sendo que o primeiro é o campo que será
utilizado para associar valor aos tokens, e o segundo é o campo que
será utilizado para criar a AST:
#+BEGIN_EXAMPLE
%union{
	struct valor_lexico_t* valor_lexico;
	struct nodo* no;
}
#+END_EXAMPLE
A ~struct valor_lexico_t*~ que, no teu código, é ~VALUE*~, tem sua
estrutura descrita na Sec 2.1 da espec. da E2. Chamo a atenção para o
segundo parágrafo do texto da especificação desta Sec 2.1, pois ali
descreve como o "valor do token" propriamente dito deve ser codificado
na estrutura. Veja que o ~tokenValue~ (que tu declaraste somente como
~char*~) deve ser uma ~union~ que comporta diferentes valores (int, float,
etc).

(segue na resposta da #4.2)

*** Pergunta #4.2

2) No exemplo de %union que tem nos slides da aula N3 A7, existe um
   campo chamado node* no. Ele precisa estar dentro do union também?
   Qual a relação entre o nodo e o %union?

----------

R: Então, dando prosseguimento à resposta da #4.1, temos dois campos
no %union: o primeiro para associar valor aos tokens, e o segundo para
associar valor aos não-terminais (que permitirão a criação da
estrutura da AST). No bison, o "tipo" default do valor dos tokens e
não-terminais é ~int~. Para alterar isso, precisamos efetivamente
declarar campos no %union e depois fazer o seguinte:
#+BEGIN_EXAMPLE
%token<valor_lexico> TK_IDENTIFICADOR
#+END_EXAMPLE
para dizer que o "tipo" de um token ~TK_IDENTIFICADOR~ é o campo
~valor_lexico~ da %union. E, fazer o seguinte:
#+BEGIN_EXAMPLE
%type<no> programa deffuncao
#+END_EXAMPLE
Para dizer que o "tipo" dos não-terminais programa e deffuncao,
portanto o valor associado a eles, é o campo ~no~ da %union. Feito isso,
nas regras gramaticais, tais como essa abaixo, podemos fazer uso dos
marcadores ~$$~, ~$1~, e ~$2~, sabendo que tais marcadores serão o tipo
%union declarado. Caso ~$1~ for um identificador podemos utilizar o
campo ~valor_lexico~. Caso ~$1~ for um não-terminal, saberemos que seu
valor é o que está no campo ~no~.

(segue na resposta da #4.3)

*** Pergunta #4.3

3) Também não entendi bem como funciona a yylval ao fazer a associação
   de um valor a um token. Se eu usasse a minha definição de union
   acima, seria assim a associação para, por exemplo, uma string?

#+BEGIN_EXAMPLE
{STRING} { yylval.valor_lexico.tokenValue = yytext; return TK_LIT_STRING; }
#+END_EXAMPLE

Se possível, gostaria de exemplos mais concretos em que yylval utiliza
valores contidos em %union e do armazenamento de yytext nele.

----

R: Do ponto de vista da gramática (do parser), nada mais precisa ser
feito além daquilo descrito até a resposta da #4.2. No entanto, do
ponto de vista do léxico (do scanner), precisamos garantir que quando
um ~TK_IDENTIFICADOR~ aparecer em uma regra gramatical, se a referirmos
através de $1, por exemplo, devemos acessar os dados de valor no campo
~valor_lexico~. Para que isso seja possível, precisamos usar, lá no
léxico, a variável global yylval. O tipo dessa variável é a union
declarada no comando %union do bison. Portanto, no teu código do
scanner, precisamos, imediatamente antes de retornar o token
reconhecido, alocar dinamicamente a estrutura de dados ~struct
valor_lexico_t~ (com malloc), inicializá-la corretamente, e atribuir o
ponteiro para o campo ~valor_lexico~. Essa alocação, inicialização e
atribuição pode ser feita da seguinte forma (inspirado pelo tipo que
tu estás usando):
#+BEGIN_EXAMPLE
{STRING} {
   VALUE* valor = malloc(1 * sizeof(VALUE)); // aloca a estrutura
   //TODO inicializar todos os campos da estrutura apontada por valor
   yylval.valor_lexico = valor; //atribuir para o yylval
   return TK_LIT_STRING;
}
#+END_EXAMPLE
Daí, lá na tua gramática, quando tu tiveres uma regra onde aparece um
~TK_LIT_STRING~, como:
#+BEGIN_EXAMPLE
decl_init: tipo TK_IDENTIFICADOR TK_OC_LT TK_LIT_STRING { 
#+END_EXAMPLE
Tu sabes que tu poderás recuperar o ponteiro do valor de ~TK_LIT_STRING~
através $4. Ou seja, $4 será o ~VALUE*~ que tu atribuíste lá no scanner
quando fizeste ~yylval.valor_lexico = valor~. Nota que nesse mesmo
exemplo, tu sabes que isso também é válido para ~TK_IDENTIFICADOR~ e
~TK_OC_LT~. No caso o não terminal ~tipo~ e ~decl_init~ serão do tipo ~no~ da
tua %union.

*** Pergunta #5

 A ação { $$ = NULL; } é consistente para o caso de produções que
 devem ser ignoradas?

R: Sim, tipicamente para produções cujo corpo é vazio.

*** Pergunta #6

Na função libera, posso adicionar mais um parâmetro? Queria deixá-la
assim: void libera (treeNode *root, bool primeiroUso); Isto é
permitido?

R: Não é permitido.

*** Pergunta #7

Para representarmos a árvore, ficamos confusos com uma questão:
devemos listar os endereços dos filhos nas linhas? Ou apenas o
endereço do nó?

No caso, uma linha válida seria assim:
0x55f8f45f23a0, 0x55f8f45f29100x55f8f45f23a0, 0x55f8f45f35900x55f8f45f2910 [label="<="];

Ou assim:
0x55f8f45f2810 [label="<="];
?

R: Na Sec 2.4 tem um exemplo completo sobre como exportar a
árvore. Poderias revisar e me dizer se aquilo que está lá escrito já
resolve a tua dúvida?

** DONE 2021-03-07 D2
*** Dúvida #1

Eu reli a seção 2.4 mas minha dúvida permanece. Peço desculpas pois
pode ser que seja falha de interpretação minha, mas queria confirmar
com o senhor pois parte da correção é automática, então eu e minha
dupla precisamos ter certeza do formato exato da saída. O senhor
primeiro dá um exemplo de saída CSV válida onde uma linha pode conter
múltiplos endereços de memória (onde, em cada linha, há o endereço do
nó e o endereço dos filhos do nó), mas abaixo o senhor dá um exemplo
onde cada linha possui apenas um endereço de memória. Fiquei com
dúvida se, numa linha onde vamos representar um nó que possua filhos,
o correto seja:

a) Nessa linha imprimir o endereço do nó, seguido pelos endereços dos
filhos e, por fim, o label do nó

b) Nessa linha imprimir apenas o endereço do nó seguido pelo seu label

c) Nessa linha, imprimir o endereço do nó e o label do nó, seguido
pelo endereço dos filhos e label dos filhos

---

R: No exemplo fornecido na especificação da E3 (Sec 2.4), a linha deve
conter apenas dois endereços de memória (pai, filho). Se um pai tiver
mais de um filho, então haverá uma linha para cada relação pai, filho,
conforme o exemplo fornecido. Então, nenhuma das alternativas a), b),
e c) está correta. 

R: Retomando, existem dois tipos de linha:

1/ Linhas que registram a relação entre dois nós da árvore (são
aquelas linhas que tem dois endereços separados por vírgula)

2/ Linhas que registram o nome do nó da árvore (são aquelas linhas que
tem o campo label)

Teve uma pergunta sobre isso, e acabo de falar sobre isso no video E3
D0 D1, mas tu podes olhar diretamente a Pergunta #2 do E3 D1. Então,
respondendo tua pergunta diretamente, a opção é nenhuma das
alternativas. A resposta seria:

d) Nessa linha, imprimir o endereço do nó, seguido pelo endereço de um
dos filhos. Para representar as relações de um pai com todos os seus
filhos, tu precisarás de uma linha para cada filho, como está na
especificação. Todas essas linhas são do tipo 1/ (descrito
acima). Restam as linhas do tipo /2, uma para cada nó da árvore.

*** Dúvida #2.1

obrigado pelas respostas, elas nos ajudaram a entender melhor o que
devemos fazer. Mas ainda temos algumas dúvidas:

1) No caso do literal, de que forma devo armazenar o tipo do literal?
   Posso fazer isso dentro do enum que criei para os tipos do token?
   Assim:

#+BEGIN_EXAMPLE
typedef enum {
  specialChar, compoundOperator, identifier, lit_int, lit_float, lit_bool, lit_char, lit_string  // em vez de ser só "literal", ter uma opção para cada tipo
} tipoToken;
#+END_EXAMPLE

---

R: Esse enum guarda apenas o tipo, não o valor. Um literal inteiro tem
que ser guardada em uma variável do tipo int, um literal
ponto-flutuante em um float, um caractere em um char, uma string em um
char*, um booleano em um int ou bool (se quiseres fazer um
typedef). Como um literal pode ser só de um tipo a cada vez, recomendo
colocar todos essas variáveis dentro de uma union, com uma variável
auxiliar para que tu registres qual é o tipo. A enum tu chamaste de
"tipoToken", e um tipo de token ou é specialChar, compoundOperator,
identifier, literal. Isso está no primeiro parágrafo da Sec 2.1.
Depois, tu teria um outro campo com o valor propriamente dito para
diferenciar entre os tipos de literais. Isso está no segundo parágrafo
da Sec 2.1.

*** Dúvida #2.2

2) Sobre exemplo de yylval que colocaste na resposta da minha pergunta
   3, devo fazer o mesmo para todos os tokens contidos no scanner.l
   (exceto palavras reservadas)? Por exemplo, no token ';':

#+BEGIN_EXAMPLE
";" {
  valor_lexico_t* valor = malloc(1*sizeof(valor_lexico_t));
  valor->n_linha = get_line_number();
  valor->type = specialChar;
  valor->val.s = strdup(yytext);
  yylval.valor_lexico = valor;
  return 59;
}
#+END_EXAMPLE

---

R: Não vejo necessidade de criar um valor para cada token reconhecido
pelo léxico. Um exemplo é esse do ";", pois o "valor" desse
ponto-e-vírgula não será utilizado para nada. Veja resposta da dúvida
seguinte. Ah, e um outro comentário. Troque o "return 59" por "return
yytext[0]". Teu código ficará mais legível.

*** Dúvida #2.3

3) Sobre o nodo da AST: quais são os dados essenciais que devem estar
   contidos no nodo? Sei que o valor do token (ponteiro do tipo
   ~valor_lexico_t~) e um ponteiro para os nodos filhos devem fazer
   parte do struct do nodo, mas preciso armazenar algo mais?

---

R: Com certeza precisa armazenar algo mais. Além dos ponteiros para os
filhos do nó e também do valor do token (ponteiro para o
~valor_lexico_t~, somente quando realmente necessário pois muitos nós
intermediários não são tokens), precisarás também guardar, pelo menos,
o tipo do nó da AST. Se é um IF, precisas guardar algo como ~AST_IF~. Se
é um WHILE, precisas guardar algo como ~AST_WHILE~. Se for um
identificador, será ~AST_IDENTIFICADOR~. Se for um literal, será um
~AST_LITERAL~, e assim por diante. Para os nós da AST cujo token tem
pouca utilidade (construções de fluxo de controle, por exemplo), o
valor deles pode ser NULL. De maneira ampla, o valor do token só é
realmente necessário quando temos identificadores e literais.

*** Dúvida #3

Referente à impressão da árvore, o label deve guardar o valor do
literal ou nome do identificador, portanto devem ser transformados em
string. Caso o literal seja um float, quantas casas decimais devemos
imprimir no label, ao transformar de float para char*?

---

R: Usar o formatador "%f" sem especificar a quantidade de casas
decimais. Para o literal int, usar o "%d"; para tudo que é string,
"%s", para caractere "%c" e para booleano usar %d.

*** Dúvida #4

Tenho uma dúvida sobre desalocar a memória no trabalho. Alguns tokens
com valor léxico não fazem parte da árvore, por exemplo o ';' deve ser
ignorado. Como devemos liberar a memória desse valor léxico se ele não
está na árvore?

---

R: Os tokens que não farão parte da árvore não precisam ter valor
léxico, portanto a alocação da estrutura não deverá nem ser
feita. Para aqueles cuja decisão de colocar ou não a árvore seja feita
tardiamente (se for o caso), pode-se tomar a decisão de liberá-los no
ponto onde eles seriam colocados na árvore, mas não o são.

*** Dúvida #5

Estou com dúvida de como precisa ser o formato específico de
exportação da árvore. Eu não entendi se deveria ser:

#+BEGIN_EXAMPLE
"nodo [label=regramentoNodo], nodoFilho"
ou
"nodo [label=regramentoNodo], nodoFilho [label=regramentoNodo]"
#+END_EXAMPLE

em que "regramentoNodo" seria o resultado depois de se decidir o label
correto de acordo com o tipo do nodo, e o "nodo" seria a posição de
memória do nodo conforme padrão %p.

Ou, ainda, se não é nenhum desses dois, como deveria ser?  Fiquei um
pouco confuso pq está escrito que uma saída CSV válida seria "nodo,
nodoFilho", mas ao falar dos labels está escrito que precisa ser uma
linha única.

Pode me esclarecer, por favor? Obrigado! 

----

R: Não é nenhum desses dois. Veja resposta da D2 #1, acima. Mas em
suma, existem dois tipos de linha: 1/ uma que representa a relação pai
e filho, que seria algo como o abaixo, usando as tuas definições
acima:

"nodo, nodoFilho"

2/ e uma para apresentar o label, assim:

"nodo [label=regramentoNodo]"

"nodoFilho [label=regramentoNodo]"

*** Dúvida #6.1

obrigado pelas respostas. Desculpe se estou fazendo muitas perguntas,
por alguma razão estou com dificuldade de interpretar o enunciado da
etapa, mas estou tentando absorver tudo aos poucos.

1) Queria saber se a minha estrutura de dados está correta, incluindo
   agora o tipo do token e o tipo do literal, e troquei o enum por um
   int.

#+BEGIN_SRC C
#define LIT_INTEGER 1
#define LIT_FLOAT 2
#define LIT_CHAR 3
#define LIT_STRING 4
#define LIT_TRUE 5
#define LIT_FALSE 6

#define SPECIAL_CHAR 8
#define COMPOUND_OPERATOR 9
#define IDENTIFIER 10
#define LITERAL 11

typedef union {
  int i;
  float f;
  int b;  // boolean
  char c;
  char* s;
} Valores;

typedef struct {
  int tipo;
  Valores val;
} TipoLiteral;

typedef struct {
  int n_linha;
  int tipoToken;
  TipoLiteral tipoLit;
} valor_lexico_t;

typedef struct {
  valor_lexico_t* valor;
  struct nodo* filhos[4];
  int tipoNodo;
} nodo;
#+END_SRC

---

R: Acho que está no bom caminho! Algumas ressalvas: 1/ como tu farás
para guardar o valor do identificador (o lexema)? Uma opção,
resguardado problema de legibilidade, seria usar o campo s do
TipoLiteral. 2/ A quantidade máxima é de 4 filhos, o que tu farás se
houver mais (acredito que não aconteça no nosso exemplo, mas veja que
a árvore se torna limitada). 3/ E para aqueles nós que tem menos que
quatro filhos, certamente teríamos um desperdício de memória, ainda
que mínimo. Minha sugestão seria usar realloc para usar apenas aquilo
que tu realmente precisas de memória no campo "filhos".

*** Dúvida #6.2

2) Surgiu outro problema: estou testando o alocamento de um valor para
   uma string sem as aspas, e estou obtendo erro de segmentation
   fault. Estou usando strncpy para remover as aspas, e é ele que está
   causando o problema. No momento fiz assim:

#+BEGIN_SRC C
{STRING} {
  valor_lexico_t* valor = malloc(1*sizeof(valor_lexico_t));
  valor->n_linha = get_line_number();
  valor->tipoToken = LITERAL;
  valor->tipoLit.tipo = LIT_STRING;

  strncpy(valor->tipoLit.val.s, &yytext[1], strlen(yytext)-2);
  yylval.valor_lexico = valor;

  return TK_LIT_STRING;
}
#+END_SRC

Qual seria uma alternativa? Tentei pesquisar, mas não encontrei. 

---

R: É normal, tu estás copiando o conteúdo a partir de yytext[1] para
um ponteiro para o qual tu não alocaste espaço com malloc (o campo
s). Como este campo provavelmente tem o valor zero (um ponteiro nulo),
tu obténs o bom segfault. Sugiro rever as aulas de programação em C
(na parte de ponteiros), assumindo que no teu percurso tu já viste
como alocar dinamicamente memória com malloc/etc. O segfault é o
melhor dos erros, basta compilar com símbolos (por exemplo passando -g
para o compilador) e depois lançar o depurador gdb. Ele vai te dizer
exatamente a linha onde aconteceu a falha de segmentação (o acesso
inválido). Minha sugestão adicional é, tendo o programa funcionando,
lançar o programa valgrind para averiguar todos os erros de memória
que estão passando despercebidos.

*** Dúvida #6.3

No e-mail que enviei há pouco, esqueci de mencionar um detalhe na
pergunta 1 sobre minha estrutura de dados: para armazenar o valor do
identificador, posso usar o char* s contido no union Valores, apesar
de ele não ser um literal? Ou devo fazer isso em outro lugar? Porque
como ele não é um literal, ele não terá tipo no struct TipoLiteral.

---

R: Como podes ter visto na minha resposta anterior em #6.1, esse foi
meu primeiro questionamento. Tu poderias alternativamente ter um campo
extra em ~valor_lexico_t~ para guardar o lexema do token
reconhecido. Esse campo seria definido para todos os tokens (afinal
todos tem seus lexemas), mas só seria de fato útil para os
identificadores, tendo em vista que, se uma string literal, é no campo
s que tu guardarás a string sem as aspas.

*** Dúvida #7.1

1 - Na especificação consta que devemos ignorar bloco de comandos. Não
entendemos se devemos simplesmente ignorar todos os comandos dentro do
mesmo ou se só não aparece um "nodo de bloco de comandos" na AST.
Exemplo : {foo(); bar();}. Pela segunda alternativa o mesmo seria
equivalente a uma lista de comandos (foo(); bar();) simples.

R: Ignorar o bloco de comandos no contexto da AST, ou seja, deve-se
apenas fazer com que ele não apareça na AST. Exemplo:
#+BEGIN_EXAMPLE
int main() {
   foo();
   {
      bar();
   };
   chu();
}
#+END_EXAMPLE
A AST terá foo(); bar(); e chu(); encadeadas dentro de main().

*** Dúvida #7.2

2- A função exporta() deve imprimir primeiramente os relacionamentos
entre nodos e posteriormente todos labels dos nodos ou eles podem ser
impressos misturados?

R: Podem ser impressos misturados. O script de avaliação é robusto o
suficiente para separar os dois tipos de linhas.

*** Dúvida #7.3

3 - Para Operadores como +, -, /, *, !  em que um nodo deve ser
criado, esse nodo precisa possuir informações sobre seu valor léxico
como tipo do token, tipo do valor e demais campos, ou basta apenas
armazenar o caractere como label do nó sem a necessidade de preencher
o valor léxico?

R: Operadores em geral não precisam ter um valor léxico tendo em vista
que o próprio tipo do nó da AST já codifica suficientemente a sua
semântica. Por exemplo, o nó da AST + com dois filhos é uma soma
binária; o nó da AST + com somente um filho é um + unário.

*** Dúvida #7.4

4 - Literais string e char devem ter todas ocorrências de aspas
removidas ou apenas as aspas de abertura e fechamento de literal? A
especificação dá a entender que todas as aspas devem ser removidas,
mas ao nosso ver faz mais sentido remover só as de abertura e
fechamento da string/char, já que em C a string "\"" é valida, por
exemplo.

R: Somente as aspas de abertura e fechamento dos literais string e
caractere. Veja que alguns grupos implementaram aspas escapadas (e de
uma maneira geral, caracteres escapados). É neste momento que estes
caracteres escapados deverão ser tratados se for o caso.

*** Dúvida #7.5                                                    :ATTACH:
:PROPERTIES:
:Attachments: graphviz.png
:ID:       d91fac6a-c963-48a2-bcb8-8dfa50ecc86b
:END:

5 - Como vamos diferenciar o próximo comando de um (if sem else
opcional) para um comando de um if com else? No caso de um if sem else
opcional o seu terceiro filho não existe, porém caso haja um comando
subsequente ao if, este filho seria o próximo comando. Para
exemplificar essa situação, segue o link para visualização de uma
árvore exemplo:

#+attr_latex: :width .4\linewidth
[[./data/d9/1fac6a-c963-48a2-bcb8-8dfa50ecc86b/graphviz.png]]

Essa é a árvore para o seguinte código:

#+BEGIN_EXAMPLE
int testIOCommand() {
  if(semElse){
    output esseIfNaoTemElse;
  }

  if(comElse){
    output esseIfTemElse;
  }
  else{
    output oElse;
  }
}
#+END_EXAMPLE

Ao verificar a saída ficamos em dúvida em como interpretaríamos a
árvore em etapas subsequentes, já que a priori não há como diferenciar
os dois ifs.

R: Existem várias formas. Por exemplo, podes empregar um tipo
específico de nó da AST para quando o if não tem else e outro para
quando o if tem o else. Outra forma é através de um filho especial
para indicar o próximo. Como escrevi, existem várias formas de
resolver isso e eu deixo para vocês resolverem da forma que acharem
mais elegante. Lembro que para a E3 em si, isso não é majoritariamente
importante tendo em vista que não geramos código ainda. Mas
certamente, quando a E5 chegar, todos precisaremos se preocupar com
isso. Reforço que, do ponto de vista do label, o if, seja com ou sem
else, sempre terá seu label if.

*** Dúvida #7.6                                                    :ATTACH:
:PROPERTIES:
:Attachments: caso1.png caso2.png
:ID:       f8594c49-105e-4341-b0fb-5a6af44a6df4
:END:

6 - Para listas de inicialização na hora de declarar variáveis, o
correto é encadear cada inicialização como encadeamos listas de
comandos? E nesse caso, o próximo comando a essa lista de
inicialização deve ser filho da primeira inicialização ou da última
inicialização?

Link para o caso de filho da primeira inicialização: 
#+attr_latex: :width .4\linewidth
[[./data/f8/594c49-105e-4341-b0fb-5a6af44a6df4/caso1.png]]

Link para o caso de filho da ultima inicialização:
#+attr_latex: :width .4\linewidth
[[./data/f8/594c49-105e-4341-b0fb-5a6af44a6df4/caso2.png]]

R: Cada inicialização em uma lista de declarações deve ser encadeada
como se fosse um comando. Se houver uma declaração sem inicialização
no meio de declarações com inicialização, essa deve ser ignorada (ou
seja, não deve fazer parte da AST). A ordem deve ser respeitada e
integrada com os demais comandos daquela função. O próximo comando
deve ser filho da última inicialização (de maneira que as
inicializações sejam integradas como se fossem comandos normais
simples, que de fato são).

** TODO 2021-03-08 D3
*** Dúvida #1


Ainda sobre a questão do if else opcional, dado que na correção serão
aplicados testes automatizados, a nossa escolha em como representar um
if sem else e um if com else não poderá ocasionar possíveis erros nos
testes? Por exemplo:

#+BEGIN_EXAMPLE
if (expressao) {
   output "Comandos caso verdadeiro";
}
output "Um comando qualquer";
#+END_EXAMPLE

Nesse caso o nó if possuirá 3 filhos: a expressão, o primeiro comando
em caso verdadeiro e o primeiro comando após o if. Esse exemplo
poderia ser confundido com a representação de um if com else, o qual
possuiria também 3 filhos: a expressão, o primeiro comando em caso
verdadeiro e o primeiro comando em caso falso.

#+BEGIN_EXAMPLE
if (expressao) {
   output "Comandos caso verdadeiro";
} else {
   output "Um comando qualquer";
}
#+END_EXAMPLE

A simples inspeção/visualização da estrutura da árvore gerada para
esses dois casos poderia notar dois significados distintos. Alguma
ação deve ser tomada na representação da árvore de comandos if else
opcional para que uma possível dupla representação como essa fosse
evitada?

---

R: A avaliação automática é concebida para evitar estes casos (por
exemplo, os arquivos de teste testam em separado tais casos). Mas
mesmo que haja um caso como o acima (é uma boa ideia colocá-lo em
prática para ver o encadeamento de comandos), o script de comparação
com a árvore AST de referência faz uma busca exaustiva para fazer o
casamento em cada nível da árvore, garantido que se ele não encontrou
uma subárvore idêntica, é porque ela realmente não existe. Conclusão,
fiquem tranquilos. Vocês terão acesso à árvore de referência e aquela
gerada por vocês e poderão questionar se por acaso alguma situação
peculiar passou desapercebida.

R: Complementando. Estou procurando aplicar um algoritmo de comparação
de árvores que permita um degradê de nota ao invés de algo binário
(acertou/errou) e que ao mesmo tempo faça sentido para nosso caso de
comparação de ASTs. Existe uma implementação interessante no link
github abaixo, mas ainda não consegui convergir para algo utilizável
no processo de avaliação objetiva da E3. Se vocês tiverem sugestões,
fico agradecido.

https://github.com/timtadh/zhang-shasha

*** Dúvida #2

E também, apenas para ter certeza, a análise da saída do valgrind será
considerada apenas para aqueles casos em que a entrada representa um
programa válido, ou seja, programas em que não há erros léxicos. Logo,
nos casos em que há erros léxicos na entrada a saída do valgrind pode
conter valores diferentes de zero para blocos e bytes. Correto?

---

R: Correto. Para simplificar, apenas serão testadas entradas lexica e
sintaticamente corretas. Recomendo mesmo assim refletir de como
ficaria a implementação de vocês no quesito liberação de memória na
presença de tais tipos de erros.

*** Dúvida #3

Esquecemos de mencionar no último e-mail, nas regras gerais de entrega
fala sobre os arquivos estarem no diretório raiz.  Pra melhor
organizar o código utilizamos um estrutura assim:

#+BEGIN_EXAMPLE
./src
     arquivosAuxiliares.c
     ...
main.c
parser.y
scanner.l
Makefile
#+END_EXAMPLE

Visto que os principais arquivos estão na raiz do projeto e que o
Makefile fornecido compila corretamente na raiz do projeto, podemos
manter, por motivos de organização, os arquivos auxiliares do projeto
na pasta ./src presente na raiz?

---

R: Sem problemas com esta organização.

*** Dúvida #4

Tivemos a ideia de colocar a palavra reservada no campo de valor
léxico de cada nodo da arvore - isso ajudaria muito a diminuir os
tipos de nodo da arvore, i.e. não precisaria de um nodo INPUT e um
nodo tipo OUTPUT, seria so colocar "input" e "output" no campo do
valor. Porém, lendo a especificação, percebemos que o senhor menciona
que os valores podem ser do tipo "operadores compostos, caracteres
especiais, literais e identificadores" - não palavras reservadas.

--- 

R: Tem questionamentos sobre esse assunto já respondidos nos vídeos de
dúvidas, recomendo olhar diretamente os PDFs disponibilizados e
procurar por ~valor_lexico_t~. Sobre o questionamento de vocês, entendi
que vocês projetaram o programa de maneira que cada nó da árvore de
vocês tem um valor léxico. Isso não faz muito sentido pois valores
léxicos só são realmente necessários para identificadores e literais e
estes devem ser encapsulados em nós da árvore. Sim, na especificação
falo também de outros, mas são os identificadores e literais cuja
importância é mais proeminente.

Pelo que segue no parágrafo de vocês "não precisaria de um nó INPUT e
um nó tipo OUTPUT" entendo que vocês não estão colocando na árvore um
nó da AST do tipo ~AST_INPUT~ e ~AST_OUTPUT~. No lugar, colocam apenas o
valor léxico (por favor, me ajude caso não entendi corretamente o que
vocês fizeram). Isso não está de acordo com a especificação pois lá
está escrito que deve haver um nó na AST para input e outro para
output. Cada um desses tem filhos, conforme a especificação. Se vocês
trocarem o nó da AST pelo valor léxico em si do comando, como farão
para adicionar os filhos necessários na AST para cada um desses
comandos? Então, se interpretei corretamente o que vocês escreveram,
considero errada a abordagem descrita.

*** Dúvida #5

Estou com uma dúvida sobre prints de endereços de memória.
Estou rodando meu exporta() num arquivo teste assim:

#+BEGIN_EXAMPLE
int xis;

int hello() {
  ypsilon = "hello";
  xis = 1.2;
}
#+END_EXAMPLE

E estou tendo este resultado:

#+BEGIN_EXAMPLE
0x7ffeeb0c2790 [label="AST_INICIO"];
0x7ffeeb0c2790, 0x7fc506c05ec0
0x7ffeeb0c2790, 0x7fc506c05ec8
0x7ffeeb0c2760 [label="AST_INICIO"];
0x7ffeeb0c2760, 0x7fc506c05ba8
0x7ffeeb0c2730 [label="AST_VAR_GLOBAL_DECL"];
0x7ffeeb0c2730, 0x7fc506c05b70
0x7ffeeb0c2700 [label="AST_TYPE_ID"];
0x7ffeeb0c2700, 0x7fc506c05b40
0x7ffeeb0c26d0 [label="AST_PR_INT"];
[1]    19470 segmentation fault  ./etapa3 < test1.txt
#+END_EXAMPLE

O nodo terminado em 2790 está printando seus dois filhos, terminados
em 5ec0 e 5ec8, mas quando o primeiro filho do nodo 2790 é printado,
aparece com o endereço terminado em 2760, ao invés do esperado 5ec0.

Mesmo em um exemplo mais simples, onde fiz apenas 2 nodos(1 pai e 1
filho) quaisquer para testar, obtive:

#+BEGIN_EXAMPLE
0x7ffd72800d40 [label="AST_INICIO"];
0x7ffd72800d40, 0xe142b0
0x7ffd72800bb0 [label="AST_DECLARACOES"];
#+END_EXAMPLE

Nesse pequeno exemplo, o nodo filho aparece como aquele terminado em
42b0, mas quando este vai ser printado com seu label, o endereço se
torna terminado em 0bb0. No meu entendimento, os parâmetros de função
na chamada recursiva não deveriam mudar seus endereços de memória
estando na pilha. Por que está mudando?

Caso precise, meu código do exporta() está em anexo no ast.c. O
switch-case ainda está incompleto, creio que colocamos mais do que
precisava, mas isso será visto depois.

---

R: Tu tens na função exporta:
#+BEGIN_EXAMPLE
  node* tree = (node*)arvore;
#+END_EXAMPLE

Portanto tree é um ponteiro. Depois tu imprimes assim:

#+BEGIN_EXAMPLE
printf("%p [label=\"", &tree);
#+END_EXAMPLE

Veja que tu estás pegando o endereço da variável local (&tree) ao
invés do valor guardado nela (tree), que é o valor para onde ela
aponta, que é o que tu procuras tendo em vista que tu precisas do
endereço da memória apontada por tree. Sugiro revisar as aulas sobre
ponteiros.

Aproveitando a mensagem, nenhum dos labels do código enviado está de
acordo com o que está na especificação. Sugiro revisar a Sec2.4, no
parágrafo que começa com "O nome que deve ser utilizado no campo label
deve seguir o seguinte regramento. Para funções, ...".

*** Dúvida #6.1

1) A nossa função de criar nodo (usada nas ações do parser.y) recebe
   como parâmetro o tipo do nodo, o valor de tipo ~valor_lexico_t~, e os
   nodos filhos. Nela, Criamos um novo nodo, e nele colocamos o tipo,
   o valor (se tiver) e os filhos (se tiver). Está correto isso? O
   valor deve ser setado dentro dessa função?

---

R: Existem várias formas de fazer, mas essa forma me parece adequada.

*** Dúvida #6.2

2) Nas ações das regras do parser.y, preciso chamar a função de criar
   nodo para quais regras? Seriam somente as que tem identificadores e
   literais? Por exemplo, nesse trecho:

#+BEGIN_EXAMPLE
programa: inicio                           { arvore = (void*)$1; }
    ;

inicio:
      inicio declaracoes                   { $$ = createNode(AST_INICIO, 0, $1, $2, 0, 0); }  // AST_INICIO = tipo, 0 = valor (não tem), restante = filhos
    | %empty                               { $$ = 0; }
    ;

declaracoes:
      var_global                           { $$ = $1; }
    | funcao                               { $$ = $1; }
    ;
#+END_EXAMPLE

Preciso criar o nodo na regra "inicio declaracoes"?

---

R: A escolha de quais regras gramaticais devem receber código para a
criação da AST faz parte do trabalho da E3. Depende da forma da AST
(está na especificação) e de como está organizada a gramática. Lembro
que, como vimos nas video-aulas, a AST é uma árvore única para todo o
programa da entrada, então é bastante importante que as várias
subárvores sejam todas conectadas em uma grande árvore cuja raiz está
em ~arvore~ (a dita variável global).

*** Dúvida #6.3

3) Na nossa função exporta, estamos fazendo um switch-case com todos
   os tipos de nodos que criamos e printando o que for
   necessário. Porém, para alguns tipos (como o ~AST_INICIO~ mostrado na
   pergunta 2 acima), não sabemos o que deve ser printado no
   "[label=", pois nessas regras não existe um lexema que deve ser
   printado. Devo printar algo, ou esse nodo não deveria existir?
   Devemos definir tipos de nodos somente para as regras que contém
   lexemas que devem ser printados?

---

R: A raiz da árvore é a primeira função do programa, os labels dos nós
~AST_FUNCAO~ são o nome da função, conforme o que está lá na
especificação. Lembrando que um programa é um encadeamento de
funções. Portanto, respondendo a pergunta: esse nó ~AST_INICIO~ não deve
existir. Lembra que a AST é uma simplificação da árvore de derivação?
Na especificação da E3 a nossa AST é uma super simplificação. Sobre o
último questionamento: os tipos de nós que devem ser usados estão na
especificação. Nenhum a mais é necessário.

*** Dúvida #6.4

4) Tentamos printar o lexema de um identificador, e, em vez de printar
   somente o identificador, foi printado ele e todo o código que vem
   depois dele no arquivo de teste. Quando detectamos um
   identificador, estamos printando o lexema usando printf("%s",
   arvore->valor->lexema). O que poderia estar causando todo o resto
   do código estar sendo armazenado em arvore->valor->lexema?

---

R: Não tive vistas no código, então estou assumindo que vocês tem um
campo ~char *lexema~ e fizeram em algum ponto ~lexema = yytext~. Lembrando
que yytext é um ponteiro unicamente válido imediatamente antes de
retornar o token lá no léxico. É por causa disso que eu expliquei no
vídeo de lançamento que deve-se fazer uma cópia do seu conteúdo com a
função ~strdup~. Mas atenção, ~strdup~ aloca memória dinamicamente,
portanto vocês precisarão fazer um ~free~ de lexema lá no final para o
~valgrind~ dizer que está tudo bem.

*** Dúvida #6.5

5) No último PDF e vídeo de dúvidas, o senhor mencionou o uso de -g e
   gdb para identificar segmentation faults. Poderia dar um exemplo de
   como seria executar esses comandos pela linha de comando? Pergunto
   porque não tenho tanta experiência com linha de comando e por nunca
   ter usado essas ferramentas.

---

R: Vejam este vídeo:
https://moodle.ufrgs.br/mod/page/view.php?id=2415095

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os vídeos sobre o Bison e a especificação ...
... gostaria de validar se é de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declarações de tokens usei construções como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

É desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redundância?

*** Pergunta #2

... não me parece claro como, no arquivo parser.y, teremos acesso à
variável "arvore" declarada no arquivo main.c, para que possamos
construí-la usando as ações do parser. Ela não deveria ser passada
para a função yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especificação
  - Nó ~return~ da AST tem um filho, que é uma expressão
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especificação e tentando ir de acordo com os
comentários no primeiro vídeo de dúvida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de código C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso está causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adição sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Porém, fazendo a declaração dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos só definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Está certo deixar assim?

*** Pergunta #2

Não entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os próprios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Você pede pra que os valores dos tokens sejam tratados de forma
correta em relação ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas não sabemos agora
como transformar o conteúdo do ~yytext~ em 1 único char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisaríamos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se pegássemos o conteúdo direto de
~yytext[1]~ já teríamos o valor dele, já sem as aspas.

** DONE 2020-09-29 D2
*** Dúvida #1

É possível acessar a variável yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compilação.

*** Dúvida #2

Na seção 2.3, item 1, é dito que as declarações de funções devem ter
dois filhos: O primeiro comando e a próxima função.

1. Isto significa, então, que não devemos salvar a assinatura da
   função (os parâmetros que pode receber) como seus filhos?

2. Da mesma forma, não precisamos, então, salvar a declaração de
   variáveis globais na AST, visto que as funções apontam apenas para
   a próxima função?

3. Também relacionado a variáveis, nas variáveis locais precisamos
   colocar na AST apenas aquelas que são inicializadas (e.x. int x <=
   5;) e ignorar aquelas que não são (e.x. int x;)?

*** Dúvida #3

1. Na parte que fala sobre a exportação (impressão) da Árvore, você
   não fala nada sobre os comandos de "input" e "output". Não devemos
   printar eles?

   Na parte de chamar uma função, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que serão separados por vírgula ou algo assim) ?

*** Dúvida #4

2. Na parte de montar a arvore, diz que não devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** Dúvida #5

3. Uma dúvida em relação a montagem da ast, por exemplo na criação de
   um nodo para a declaração de função, na especificação diz que deve
   ter pelo menos dois filhos (primeiro comando e a próxima
   função).

   Sobre isso, estamos criando um nodo de função que tem só um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declaração e depois para a próxima função. Queria entender se
   está correto fazer desta maneira, e se tem alguma implicação na
   parte de exportar a árvore (se teria problema em relação aos
   ponteiros na correção).

*** Dúvida #6

4. Na associação dos tokens no yylval, pensando nos caracteres
   especiais, não entendi como fazemos a relação deles com os valores
   do parser, sendo que no parser definimos esses símbolos ('+' e '-')
   manualmente nas expressões.

*** Dúvida #7

Acho que tinha me confundido nessa parte do chamar a função.

Nós vamos imprimir toda a estrutura da árvore em ponteiros (com suas
relações) e depois vamos identificá-los com os labels, certo?

Então nesse caso da chamada de função teremos o ponteiro da chamada e
depois x outros ponteiros que serão os parâmetros sendo passados? 

*** Dúvida #8

A impressão do "proximo" de um comando é feita da mesma forma que para
um filho?

*** Dúvida #9

Gostaria de pedir também se tens um exemplo um pouco maior de saída?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execução seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** Dúvida #5

Para mim, a questão do input e output ficou mais confusa após ter sido
dito que não é necessário imprimir o nó desses comandos se a
especificação não diz nada a respeito. Mas a especificação diz que
eles devem ter pelo menos um filho: a variável a ser lida ou
escrita. Gostaria de saber se esses comandos não devem mais fazer
parte da árvore ou não.

Resposta: output e input devem fazer parte da AST!
- Ver Dúvida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia à ausência de
labels para esses comandos na especificação. Meu pensamento inicial é
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anotação Prof.
- Ver "Dúvida #3"

*** Dúvida #1

Queria só confirmar sobre a exportação para os comandos "input" e
"output". No vídeo de dúvidas anterior você disse que como não é
falado no enunciado sobre a exportação deles não precisamos
trata-los. 

Resposta Prof.: Sim, precisamos tratá-los.

Quando diz que "não precisamos", ainda seria válido exportar eles?

Resposta Prof.: Totalmente válido!

Como fazemos a construção deles na árvore seria mais simples exportar
junto, especialmente na impressão da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de saída é
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Então, na E3:
  - Nó da AST =input= (label "input") tem pelo menos um filho
    - Um nó identificador
  - Nó da AST ~output~ (label "output") tem pelo menos um filho
    - Um nó identificador OU um nó literal

*** Dúvida #2 / Compartilhamento

"Script python para converter saída para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, nós do grupo J fizemos um pequeno script que faz
a "tradução" para o formato que o dot espera. Isso facilita bastante a
correção das saídas. Sabemos que é um código bem simples, mas pensamos
que pode ajudar outros grupos. Envio o código em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a saída para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe é que utilizando os endereços originais o dot não
funcionou, então mudamos os nomes para n0, n1, n2 ... nN.

O grupo não garante corretude e adverte para usar com suas contas e
riscos 😅

*** Dúvida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", já que seria necessário na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma expressão unária '-' que tem o filho "int 10",

   +ou se é necessário tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** Dúvida #4

Uma dúvida (ou mais uma curiosidade) sobre a liberação de memória. Na
avaliação com o valgrind, precisamos apenas garantir que não haverá
leak de memória nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto está dando leak, o que acredito que é o
esperado já que não estamos fazendo nenhum tratamento em passos
intermediários da construção (como a ast não vai ser montada
completamente, fazendo a ligação entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermediários da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** Dúvida #6

Se alguma expressão do for possuir o operador unário interrogação (?)
ou o ternário (?:), poderia isso gerar problemas de precedência não
contemplados pelas regras de precedência da linguagem C? Se sim, como
devemos resolver esses problemas?
