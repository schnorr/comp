# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+TITLE: D√∫vidas da E3 do Projeto de Compilador
#+Author: Lucas Mello Schnorr
#+Date: schnorr@inf.ufrgs.br
#+Language: pt-br

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, a4paper]
#+LATEX_HEADER: \input{org-babel.tex}

#+OPTIONS: toc:nil title:nil
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* E3 2020/2
** TODO 2021-03-03 D0
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao inv√©s de C?
Precisar√≠amos mudar o main.c para main.cpp, mas isto facilitaria para
a constru√ß√£o da √°rvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma √°rvore com um n√∫mero arbitr√°rio de filhos em
cada n√≥. Podemos fazer esta altera√ß√£o?

R: Pode sim (usar C++), mas n√£o vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as fun√ß√µes em arquivos separados, cpp, que
s√£o chamadas pelo c√≥digo em C normal como est√° no main.c.
*** Pergunta #2.1

1) Precisamos colocar tipo nos tokens? Por exemplo: ~%token<valorReal>~
   ~TK_LIT_FLOAT~, ou somente a declara√ß√£o do ~valor_lexico~ √© suficiente?
   Se precisamos, temos como reaproveitar as defini√ß√µes do
   ~valor_lexico~?  Como far√≠amos isso?

R: Somente a declara√ß√£o do valor l√©xico √© suficiente, e recomendada de
acordo com a especifica√ß√£o. Nota que somente assim poderemos ter
acesso a uma estrutura gen√©rica que poder√° ser tratada independente de
qual √© o valor do token por tr√°s. Esse valor do token n√£o ser√°
perdido, temos descritores dentro da estrutura valor l√©xico que ser√£o
respons√°veis por diferenciar os tipos de literais, por exemplo.

*** Pergunta #2.2

2) Qual o tipo de dado de cada elemento da arvore? Seria a estrutura
   que cont√©m n√∫mero da linha, tipo e valor?

R: Cada n√≥ da √°rvore deve ser de um tipo estrutura de dados definida
pelo grupo. Tipicamente, usa-se uma estrutura de √°rvore gen√©rica
n-√°ria com um campo de usu√°rio, onde nesse campo de usu√°rio o grupo
poder√° adicionar informa√ß√µes relativas √† AST (tipo do n√≥, etc).

*** Pergunta #2.3

3) Para construirmos a arvore, pensamos em duas fun√ß√µes:

    - Uma que cria e retorna uma folha e, se a arvore esta vazia,
      atribui √† arvore esta folha

    - Uma que recebe dados e filhos, cria um nodo, insere mais um
      filho e coloca a arvore nesse filho, depois atribui √† arvore
      este novo nodo

Isto est√° correto? √â assim mesmo para construirmos a √°rvore?

R: Uma folha √© um n√≥ sem filhos, ent√£o acho improdutivo ter um n√≥ tipo
folha e um n√≥ tipo intermedi√°rio. Conforme descrito na Sec 2.2, acho
que √© importante ter fun√ß√µes de cria√ß√£o de n√≥s e adi√ß√£o de filhos. A
constru√ß√£o da √°rvore em si √© feita atrav√©s das regras do bison. Um
exemplo, como criar a AST para a regra abaixo:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um n√≥ da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Perceba o uso de $1 e $3 conforme vimos no video bison parte 2.  No
exemplo acima, apenas duas fun√ß√µes foram necess√°rias (~ast_create~ e
~ast_add_child~). Fica a crit√©rio do grupo empregar fun√ß√µes mais
sofisticadas se preferirem.

*** Pergunta #3

 Para representarmos uma express√£o tern√°ria na √°rvore sint√°tica
 abstrata, posso considerar apenas a interroga√ß√£o (?) como pai e os
 tr√™s outros operandos como filhos, ignorando os dois pontos (:)?

R: Pode. Mas veja que na pr√°tica, a interroga√ß√£o e os dois pontos s√£o
um √∫nico operador. Inclusive, chamos a aten√ß√£o para o que est√°
explicitado na Sec 2.4: "No caso do operador tern√°rio, deve ser
utilizado o nome '?:'.", mas isso apenas na sa√≠da. A tua AST pode
conter o tipo que quiser, como ~AST_TERNARY~ ou algo assim.

*** Pergunta #4

 Estou com dificuldade de entender como funciona o processo de
 constru√ß√£o da √°rvore sint√°tica quando h√° m√∫ltiplas linhas de
 c√≥digo. Em especial, como fazemos a inser√ß√£o de folhas e de nodos com
 filhos? Nodos folhas devem ser inseridas onde? Nodos com filhos devem
 tornar-se pais do resto da arvore ou seguir como filhos da raiz? Como
 sabemos qual nodo √© pai dos nodos filho?

R: Recomendo fazer um programa completo escrito na nossa linguagem e
executar o nosso compilador da seguinte forma:

#+BEGIN_EXAMPLE
./etapa3 < arquivo_com_programa_com_multiplas_linhas
#+END_EXAMPLE

Para fazer a inser√ß√£o de n√≥s e filhos, deve-se empregar totalmente os
marcadores especiais do bison para isso, atrav√©s da adi√ß√£o de c√≥digo
no final de cada regra gramatical, pois √© ele que ir√° decidir a ordem
que estes c√≥digos ser√£o criados. Por exemplo, para a regra gramatical
que envolve o reconhecimento sint√°tico da soma bin√°ria:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um n√≥ da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Neste caso acima, temos um n√≥ intermedi√°rio de soma que tem dois
filhos. N√≥s criamos um novo n√≥ da nossa AST, com o tipo ~AST_SUM~, e o
atribu√≠mos para $$, que √© o marcador especial do bison para se referir
a cabe√ßa da produ√ß√£o gramatical. Em seguida, adicionamos dois filhos,
primeiro o filho $1 e depois o filho $3 que s√£o respectivamente os
dois operandos E do corpo da produ√ß√£o. Veja que esses operandos s√£o
tamb√©m do n√£o-terminal E, ent√£o podemos sem d√∫vida assumir que os n√≥s
da AST deles j√° foram criados pela execu√ß√£o de c√≥digo associado √†s
outras regras gramaticais (inclusive essa mesma).

*** Pergunta #5

 Para representar a √°rvore, pensamos numa estrutura onde um nodo
 indica um pr√≥ximo irm√£o e um pr√≥ximo filho, ou seja, √© uma √°rvore
 cujos filhos s√£o listas encadeadas. Isto √© permitido?

R: Recomendo a leitura da Sec 2.2 da especifica√ß√£o. Em geral, eu n√£o
recomendo esse tipo de estrutura onde os irm√£os est√£o conectados pois
ela n√£o √© natural no contexto de uma AST. N√£o teremos rela√ß√£o diretas
entre irm√£os, apenas entre pai e seus filhos. Se algo preciso ser
feito entre irm√£os, √© o pai que se ocupar√°.

** TODO 2021-03-04 D1
*** Pergunta #1

Ficou claro para mim como devo lidar com ~$$~ nas produ√ß√µes, por√©m ainda
fiquei com uma d√∫vida: como fazemos para associar ~$$~ com a vari√°vel
void* arvore? Al√©m disso, este void eu vou trocar para a minha struct
de nodo, certo? Ficar√° node* arvore, certo?‚Äã

R: A vari√°vel global ~arvore~ est√° definida no arquivo main.c e √©
declarada como ~void*~, ou seja, ~arvore~ √© um ponteiro para qualquer
coisa. √â prefer√≠vel que sua defini√ß√£o n√£o mude. Para integrar o que
voc√™s far√£o com o comportamento imut√°vel do main basta, no parser.y,
declarar a vari√°vel ~arvore~ como ~extern~, da seguinte forma:
#+BEGIN_EXAMPLE
extern void *arvore;
#+END_EXAMPLE
E depois, na primeira regra gramatical, ou seja, no primeiro
n√£o-terminal a partir do qual tudo come√ßa (tipicamente ~programa~),
deve-se definir o conte√∫do da vari√°vel ~arvore~. Para evitar problemas
de compila√ß√£o, etc, o grupo pode na atribui√ß√£o for√ßar um cast. Esse
cast pode ser revertido na implementa√ß√£o das fun√ß√µes ~exporta~ e ~libera~,
cujo prot√≥tipo tamb√©m n√£o deve mudar. Como sabemos que √© a mesma
vari√°vel que vai e vem, espera-se que n√£o haver√£o problemas.

*** Pergunta #2

Eu e minha dupla n√£o entendemos muito bem como devemos percorrer a
√°rvore para print√°-la. O senhor poderia nos explicar melhor, por
favor?

R: O percorrimento da √°rvore deve ser de maneira recursiva. Para
atingir o efeito descrito na Sec 2.4 da especifica√ß√£o, deve-se, ao
chegar um determinado n√≥ da √°rvore: 1) imprimir o endere√ßo de mem√≥ria
onde est√° a estrutura de dados (usando o %p como formatador para o
printf), seguido do seu label (consultem o formato na espec. da E2),
lembrando que o valor do label depende do tipo do n√≥; 2) para cada
filho (se houver), imprimir, para cada filho, o endere√ßo de mem√≥ria do
n√≥ que estamos visitando seguido de uma v√≠rgula seguido do endere√ßo de
mem√≥ria do filho. Feito essa listagem, basta recursivamente chamar a
fun√ß√£o exporta para cada filho.

*** Pergunta #3

Na especifica√ß√£o da E3 est√° escrito que "Devem fazer parte da AST:
[...] Todos os comandos simples da linguagem, salvo o bloco de
comando" . MInha d√∫vida √©: devemos simplesmente ignorar os blocos de
comando ao criar a AST?

R: Sim. Os blocos de comando e a declara√ß√£o de vari√°veis sem
inicializa√ß√£o n√£o devem fazer parte da AST. O bloco de comando
continua sendo importante para estruturar sintaticamente o programa,
ou seja, deve fazer parte da sintaxe como na E2.

*** Pergunta #4.1

estou confuso sobre o conte√∫do do %union, mesmo tendo lido a se√ß√£o 2.1
do enunciado v√°rias vezes.

1) O enunciado diz que se sugere usar um campo de nome valor_lexico, e
   que o tipo dele √© uma estrutura de dados com 3 campos: n√∫mero da
   linha, tipo do token e valor do token. Estou com dificuldade de
   visualizar essa estrutura. Minha ideia inicial paraa fazer o %union
   foi essa:

#+BEGIN_EXAMPLE
%union
{
  VALUE *valor_lexico;
}

enum tokenType {
  specialChar, compoundOperator, identifier, literal
};

typedef struct value_struct
{
  int n_line;
  enum tokenType token_type;
  char* tokenValue;
} VALUE;
#+END_EXAMPLE

Teria alguma sugest√£o para fazer o %union de uma maneira mais simples
(por exemplo, sem o enum)?

----------

R: N√≥s vimos que a AST (veja aula N5 A0) tem n√≥s intermedi√°rios e n√≥s
folha, sendo que estas folhas s√£o frequentemente os tokens obtidos na
entrada. Por essa raz√£o, os tokens que integram as folhas na AST
(tipicamente identificadores e os literais) devem possuir um valor
pois eles integrar√£o parte da AST. Sendo esta a teoria e, por ser algo
muito frequente a ser implementado, o bison d√° um suporte completo
para essa atividade, atrav√©s do comando %union. Os campos dessa union
s√£o os poss√≠veis "valores" que podem estar associados aos tokens e aos
n√£o-terminais. Em nosso projeto, o comando %union do bison normalmente
ter dois campos, como abaixo, sendo que o primeiro √© o campo que ser√°
utilizado para associar valor aos tokens, e o segundo √© o campo que
ser√° utilizado para criar a AST:
#+BEGIN_EXAMPLE
%union{
	struct valor_lexico_t* valor_lexico;
	struct nodo* no;
}
#+END_EXAMPLE
A ~struct valor_lexico_t*~ que, no teu c√≥digo, √© ~VALUE*~, tem sua
estrutura descrita na Sec 2.1 da espec. da E2. Chamo a aten√ß√£o para o
segundo par√°grafo do texto da especifica√ß√£o desta Sec 2.1, pois ali
descreve como o "valor do token" propriamente dito deve ser codificado
na estrutura. Veja que o ~tokenValue~ (que tu declaraste somente como
~char*~) deve ser uma ~union~ que comporta diferentes valores (int, float,
etc).

(segue na resposta da #4.2)

*** Pergunta #4.2

2) No exemplo de %union que tem nos slides da aula N3 A7, existe um
   campo chamado node* no. Ele precisa estar dentro do union tamb√©m?
   Qual a rela√ß√£o entre o nodo e o %union?

----------

R: Ent√£o, dando prosseguimento √† resposta da #4.1, temos dois campos
no %union: o primeiro para associar valor aos tokens, e o segundo para
associar valor aos n√£o-terminais (que permitir√£o a cria√ß√£o da
estrutura da AST). No bison, o "tipo" default do valor dos tokens e
n√£o-terminais √© ~int~. Para alterar isso, precisamos efetivamente
declarar campos no %union e depois fazer o seguinte:
#+BEGIN_EXAMPLE
%token<valor_lexico> TK_IDENTIFICADOR
#+END_EXAMPLE
para dizer que o "tipo" de um token ~TK_IDENTIFICADOR~ √© o campo
~valor_lexico~ da %union. E, fazer o seguinte:
#+BEGIN_EXAMPLE
%type<no> programa deffuncao
#+END_EXAMPLE
Para dizer que o "tipo" dos n√£o-terminais programa e deffuncao,
portanto o valor associado a eles, √© o campo ~no~ da %union. Feito isso,
nas regras gramaticais, tais como essa abaixo, podemos fazer uso dos
marcadores ~$$~, ~$1~, e ~$2~, sabendo que tais marcadores ser√£o o tipo
%union declarado. Caso ~$1~ for um identificador podemos utilizar o
campo ~valor_lexico~. Caso ~$1~ for um n√£o-terminal, saberemos que seu
valor √© o que est√° no campo ~no~.

(segue na resposta da #4.3)

*** Pergunta #4.3

3) Tamb√©m n√£o entendi bem como funciona a yylval ao fazer a associa√ß√£o
   de um valor a um token. Se eu usasse a minha defini√ß√£o de union
   acima, seria assim a associa√ß√£o para, por exemplo, uma string?

#+BEGIN_EXAMPLE
{STRING} { yylval.valor_lexico.tokenValue = yytext; return TK_LIT_STRING; }
#+END_EXAMPLE

Se poss√≠vel, gostaria de exemplos mais concretos em que yylval utiliza
valores contidos em %union e do armazenamento de yytext nele.

----

R: Do ponto de vista da gram√°tica (do parser), nada mais precisa ser
feito al√©m daquilo descrito at√© a resposta da #4.2. No entanto, do
ponto de vista do l√©xico (do scanner), precisamos garantir que quando
um ~TK_IDENTIFICADOR~ aparecer em uma regra gramatical, se a referirmos
atrav√©s de $1, por exemplo, devemos acessar os dados de valor no campo
~valor_lexico~. Para que isso seja poss√≠vel, precisamos usar, l√° no
l√©xico, a vari√°vel global yylval. O tipo dessa vari√°vel √© a union
declarada no comando %union do bison. Portanto, no teu c√≥digo do
scanner, precisamos, imediatamente antes de retornar o token
reconhecido, alocar dinamicamente a estrutura de dados ~struct
valor_lexico_t~ (com malloc), inicializ√°-la corretamente, e atribuir o
ponteiro para o campo ~valor_lexico~. Essa aloca√ß√£o, inicializa√ß√£o e
atribui√ß√£o pode ser feita da seguinte forma (inspirado pelo tipo que
tu est√°s usando):
#+BEGIN_EXAMPLE
{STRING} {
   VALUE* valor = malloc(1 * sizeof(VALUE)); // aloca a estrutura
   //TODO inicializar todos os campos da estrutura apontada por valor
   yylval.valor_lexico = valor; //atribuir para o yylval
   return TK_LIT_STRING;
}
#+END_EXAMPLE
Da√≠, l√° na tua gram√°tica, quando tu tiveres uma regra onde aparece um
~TK_LIT_STRING~, como:
#+BEGIN_EXAMPLE
decl_init: tipo TK_IDENTIFICADOR TK_OC_LT TK_LIT_STRING { 
#+END_EXAMPLE
Tu sabes que tu poder√°s recuperar o ponteiro do valor de ~TK_LIT_STRING~
atrav√©s $4. Ou seja, $4 ser√° o ~VALUE*~ que tu atribu√≠ste l√° no scanner
quando fizeste ~yylval.valor_lexico = valor~. Nota que nesse mesmo
exemplo, tu sabes que isso tamb√©m √© v√°lido para ~TK_IDENTIFICADOR~ e
~TK_OC_LT~. No caso o n√£o terminal ~tipo~ e ~decl_init~ ser√£o do tipo ~no~ da
tua %union.

*** Pergunta #5

 A a√ß√£o { $$ = NULL; } √© consistente para o caso de produ√ß√µes que
 devem ser ignoradas?

R: Sim, tipicamente para produ√ß√µes cujo corpo √© vazio.

*** Pergunta #6

Na fun√ß√£o libera, posso adicionar mais um par√¢metro? Queria deix√°-la
assim: void libera (treeNode *root, bool primeiroUso); Isto √©
permitido?

R: N√£o √© permitido.

*** Pergunta #7

Para representarmos a √°rvore, ficamos confusos com uma quest√£o:
devemos listar os endere√ßos dos filhos nas linhas? Ou apenas o
endere√ßo do n√≥?

No caso, uma linha v√°lida seria assim:
0x55f8f45f23a0, 0x55f8f45f29100x55f8f45f23a0, 0x55f8f45f35900x55f8f45f2910 [label="<="];

Ou assim:
0x55f8f45f2810 [label="<="];
?

R: Na Sec 2.4 tem um exemplo completo sobre como exportar a
√°rvore. Poderias revisar e me dizer se aquilo que est√° l√° escrito j√°
resolve a tua d√∫vida?

** 2021-03-07 D2
*** D√∫vida #1

Eu reli a se√ß√£o 2.4 mas minha d√∫vida permanece. Pe√ßo desculpas pois
pode ser que seja falha de interpreta√ß√£o minha, mas queria confirmar
com o senhor pois parte da corre√ß√£o √© autom√°tica, ent√£o eu e minha
dupla precisamos ter certeza do formato exato da sa√≠da. O senhor
primeiro d√° um exemplo de sa√≠da CSV v√°lida onde uma linha pode conter
m√∫ltiplos endere√ßos de mem√≥ria (onde, em cada linha, h√° o endere√ßo do
n√≥ e o endere√ßo dos filhos do n√≥), mas abaixo o senhor d√° um exemplo
onde cada linha possui apenas um endere√ßo de mem√≥ria. Fiquei com
d√∫vida se, numa linha onde vamos representar um n√≥ que possua filhos,
o correto seja:

a) Nessa linha imprimir o endere√ßo do n√≥, seguido pelos endere√ßos dos
filhos e, por fim, o label do n√≥

b) Nessa linha imprimir apenas o endere√ßo do n√≥ seguido pelo seu label

c) Nessa linha, imprimir o endere√ßo do n√≥ e o label do n√≥, seguido
pelo endere√ßo dos filhos e label dos filhos

----

R: No exemplo fornecido na especifica√ß√£o da E3 (Sec 2.4), a linha deve
conter apenas dois endere√ßos de mem√≥ria (pai, filho). Se um pai tiver
mais de um filho, ent√£o haver√° uma linha para cada rela√ß√£o pai, filho,
conforme o exemplo fornecido. Ent√£o, nenhuma das alternativas a), b),
e c) est√° correta. 

R: Retomando, existem dois tipos de linha:

1/ Linhas que registram a rela√ß√£o entre dois n√≥s da √°rvore (s√£o
aquelas linhas que tem dois endere√ßos separados por v√≠rgula)

2/ Linhas que registram o nome do n√≥ da √°rvore (s√£o aquelas linhas que
tem o campo label)

Teve uma pergunta sobre isso, e acabo de falar sobre isso no video E3
D0 D1, mas tu podes olhar diretamente a Pergunta #2 do E3 D1. Ent√£o,
respondendo tua pergunta diretamente, a op√ß√£o √© nenhuma das
alternativas. A resposta seria:

d) Nessa linha, imprimir o endere√ßo do n√≥, seguido pelo endere√ßo de um
dos filhos. Para representar as rela√ß√µes de um pai com todos os seus
filhos, tu precisar√°s de uma linha para cada filho, como est√° na
especifica√ß√£o. Todas essas linhas s√£o do tipo 1/ (descrito
acima). Restam as linhas do tipo /2, uma para cada n√≥ da √°rvore.
*** D√∫vida #2.1

obrigado pelas respostas, elas nos ajudaram a entender melhor o que
devemos fazer. Mas ainda temos algumas d√∫vidas:

1) No caso do literal, de que forma devo armazenar o tipo do literal?
   Posso fazer isso dentro do enum que criei para os tipos do token?
   Assim:

#+BEGIN_EXAMPLE
typedef enum {
  specialChar, compoundOperator, identifier, lit_int, lit_float, lit_bool, lit_char, lit_string  // em vez de ser s√≥ "literal", ter uma op√ß√£o para cada tipo
} tipoToken;
#+END_EXAMPLE

-----

R: Esse enum guarda apenas o tipo, n√£o o valor. Um literal inteiro tem
que ser guardada em uma vari√°vel do tipo int, um literal
ponto-flutuante em um float, um caractere em um char, uma string em um
char*, um booleano em um int ou bool (se quiseres fazer um
typedef). Como um literal pode ser s√≥ de um tipo a cada vez, recomendo
colocar todos essas vari√°veis dentro de uma union, com uma vari√°vel
auxiliar para que tu registres qual √© o tipo. A enum tu chamaste de
"tipoToken", e um tipo de token ou √© specialChar, compoundOperator,
identifier, literal. Isso est√° no primeiro par√°grafo da Sec 2.1.
Depois, tu teria um outro campo com o valor propriamente dito para
diferenciar entre os tipos de literais. Isso est√° no segundo par√°grafo
da Sec 2.1.

*** D√∫vida #2.2

2) Sobre exemplo de yylval que colocaste na resposta da minha pergunta
   3, devo fazer o mesmo para todos os tokens contidos no scanner.l
   (exceto palavras reservadas)? Por exemplo, no token ';':

#+BEGIN_EXAMPLE
";" {
  valor_lexico_t* valor = malloc(1*sizeof(valor_lexico_t));
  valor->n_linha = get_line_number();
  valor->type = specialChar;
  valor->val.s = strdup(yytext);
  yylval.valor_lexico = valor;
  return 59;
}
#+END_EXAMPLE

-----

R: N√£o vejo necessidade de criar um valor para cada token reconhecido
pelo l√©xico. Um exemplo √© esse do ";", pois o "valor" desse
ponto-e-v√≠rgula n√£o ser√° utilizado para nada. Veja resposta da d√∫vida
seguinte. Ah, e um outro coment√°rio. Troque o "return 59" por "return
yytext[0]". Teu c√≥digo ficar√° mais leg√≠vel.

*** D√∫vida #2.3

3) Sobre o nodo da AST: quais s√£o os dados essenciais que devem estar
   contidos no nodo? Sei que o valor do token (ponteiro do tipo
   ~valor_lexico_t~) e um ponteiro para os nodos filhos devem fazer
   parte do struct do nodo, mas preciso armazenar algo mais?

-----

R: Com certeza precisa armazenar algo mais. Al√©m dos ponteiros para os
filhos do n√≥ e tamb√©m do valor do token (ponteiro para o
~valor_lexico_t~, somente quando realmente necess√°rio pois muitos n√≥s
intermedi√°rios n√£o s√£o tokens), precisar√°s tamb√©m guardar, pelo menos,
o tipo do n√≥ da AST. Se √© um IF, precisas guardar algo como ~AST_IF~. Se
√© um WHILE, precisas guardar algo como ~AST_WHILE~. Se for um
identificador, ser√° ~AST_IDENTIFICADOR~. Se for um literal, ser√° um
~AST_LITERAL~, e assim por diante. Para os n√≥s da AST cujo token tem
pouca utilidade (constru√ß√µes de fluxo de controle, por exemplo), o
valor deles pode ser NULL. De maneira ampla, o valor do token s√≥ √©
realmente necess√°rio quando temos identificadores e literais.

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os v√≠deos sobre o Bison e a especifica√ß√£o ...
... gostaria de validar se √© de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declara√ß√µes de tokens usei constru√ß√µes como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

√â desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redund√¢ncia?

*** Pergunta #2

... n√£o me parece claro como, no arquivo parser.y, teremos acesso √†
vari√°vel "arvore" declarada no arquivo main.c, para que possamos
constru√≠-la usando as a√ß√µes do parser. Ela n√£o deveria ser passada
para a fun√ß√£o yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especifica√ß√£o
  - N√≥ ~return~ da AST tem um filho, que √© uma express√£o
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especifica√ß√£o e tentando ir de acordo com os
coment√°rios no primeiro v√≠deo de d√∫vida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de c√≥digo C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso est√° causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adi√ß√£o sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Por√©m, fazendo a declara√ß√£o dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos s√≥ definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Est√° certo deixar assim?

*** Pergunta #2

N√£o entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os pr√≥prios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Voc√™ pede pra que os valores dos tokens sejam tratados de forma
correta em rela√ß√£o ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas n√£o sabemos agora
como transformar o conte√∫do do ~yytext~ em 1 √∫nico char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisar√≠amos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se peg√°ssemos o conte√∫do direto de
~yytext[1]~ j√° ter√≠amos o valor dele, j√° sem as aspas.

** DONE 2020-09-29 D2
*** D√∫vida #1

√â poss√≠vel acessar a vari√°vel yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compila√ß√£o.

*** D√∫vida #2

Na se√ß√£o 2.3, item 1, √© dito que as declara√ß√µes de fun√ß√µes devem ter
dois filhos: O primeiro comando e a pr√≥xima fun√ß√£o.

1. Isto significa, ent√£o, que n√£o devemos salvar a assinatura da
   fun√ß√£o (os par√¢metros que pode receber) como seus filhos?

2. Da mesma forma, n√£o precisamos, ent√£o, salvar a declara√ß√£o de
   vari√°veis globais na AST, visto que as fun√ß√µes apontam apenas para
   a pr√≥xima fun√ß√£o?

3. Tamb√©m relacionado a vari√°veis, nas vari√°veis locais precisamos
   colocar na AST apenas aquelas que s√£o inicializadas (e.x. int x <=
   5;) e ignorar aquelas que n√£o s√£o (e.x. int x;)?

*** D√∫vida #3

1. Na parte que fala sobre a exporta√ß√£o (impress√£o) da √Årvore, voc√™
   n√£o fala nada sobre os comandos de "input" e "output". N√£o devemos
   printar eles?

   Na parte de chamar uma fun√ß√£o, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que ser√£o separados por v√≠rgula ou algo assim) ?

*** D√∫vida #4

2. Na parte de montar a arvore, diz que n√£o devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** D√∫vida #5

3. Uma d√∫vida em rela√ß√£o a montagem da ast, por exemplo na cria√ß√£o de
   um nodo para a declara√ß√£o de fun√ß√£o, na especifica√ß√£o diz que deve
   ter pelo menos dois filhos (primeiro comando e a pr√≥xima
   fun√ß√£o).

   Sobre isso, estamos criando um nodo de fun√ß√£o que tem s√≥ um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declara√ß√£o e depois para a pr√≥xima fun√ß√£o. Queria entender se
   est√° correto fazer desta maneira, e se tem alguma implica√ß√£o na
   parte de exportar a √°rvore (se teria problema em rela√ß√£o aos
   ponteiros na corre√ß√£o).

*** D√∫vida #6

4. Na associa√ß√£o dos tokens no yylval, pensando nos caracteres
   especiais, n√£o entendi como fazemos a rela√ß√£o deles com os valores
   do parser, sendo que no parser definimos esses s√≠mbolos ('+' e '-')
   manualmente nas express√µes.

*** D√∫vida #7

Acho que tinha me confundido nessa parte do chamar a fun√ß√£o.

N√≥s vamos imprimir toda a estrutura da √°rvore em ponteiros (com suas
rela√ß√µes) e depois vamos identific√°-los com os labels, certo?

Ent√£o nesse caso da chamada de fun√ß√£o teremos o ponteiro da chamada e
depois x outros ponteiros que ser√£o os par√¢metros sendo passados? 

*** D√∫vida #8

A impress√£o do "proximo" de um comando √© feita da mesma forma que para
um filho?

*** D√∫vida #9

Gostaria de pedir tamb√©m se tens um exemplo um pouco maior de sa√≠da?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execu√ß√£o seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** D√∫vida #5

Para mim, a quest√£o do input e output ficou mais confusa ap√≥s ter sido
dito que n√£o √© necess√°rio imprimir o n√≥ desses comandos se a
especifica√ß√£o n√£o diz nada a respeito. Mas a especifica√ß√£o diz que
eles devem ter pelo menos um filho: a vari√°vel a ser lida ou
escrita. Gostaria de saber se esses comandos n√£o devem mais fazer
parte da √°rvore ou n√£o.

Resposta: output e input devem fazer parte da AST!
- Ver D√∫vida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia √† aus√™ncia de
labels para esses comandos na especifica√ß√£o. Meu pensamento inicial √©
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anota√ß√£o Prof.
- Ver "D√∫vida #3"

*** D√∫vida #1

Queria s√≥ confirmar sobre a exporta√ß√£o para os comandos "input" e
"output". No v√≠deo de d√∫vidas anterior voc√™ disse que como n√£o √©
falado no enunciado sobre a exporta√ß√£o deles n√£o precisamos
trata-los. 

Resposta Prof.: Sim, precisamos trat√°-los.

Quando diz que "n√£o precisamos", ainda seria v√°lido exportar eles?

Resposta Prof.: Totalmente v√°lido!

Como fazemos a constru√ß√£o deles na √°rvore seria mais simples exportar
junto, especialmente na impress√£o da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de sa√≠da √©
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Ent√£o, na E3:
  - N√≥ da AST =input= (label "input") tem pelo menos um filho
    - Um n√≥ identificador
  - N√≥ da AST ~output~ (label "output") tem pelo menos um filho
    - Um n√≥ identificador OU um n√≥ literal

*** D√∫vida #2 / Compartilhamento

"Script python para converter sa√≠da para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, n√≥s do grupo J fizemos um pequeno script que faz
a "tradu√ß√£o" para o formato que o dot espera. Isso facilita bastante a
corre√ß√£o das sa√≠das. Sabemos que √© um c√≥digo bem simples, mas pensamos
que pode ajudar outros grupos. Envio o c√≥digo em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a sa√≠da para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe √© que utilizando os endere√ßos originais o dot n√£o
funcionou, ent√£o mudamos os nomes para n0, n1, n2 ... nN.

O grupo n√£o garante corretude e adverte para usar com suas contas e
riscos üòÖ

*** D√∫vida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", j√° que seria necess√°rio na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma express√£o un√°ria '-' que tem o filho "int 10",

   +ou se √© necess√°rio tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** D√∫vida #4

Uma d√∫vida (ou mais uma curiosidade) sobre a libera√ß√£o de mem√≥ria. Na
avalia√ß√£o com o valgrind, precisamos apenas garantir que n√£o haver√°
leak de mem√≥ria nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto est√° dando leak, o que acredito que √© o
esperado j√° que n√£o estamos fazendo nenhum tratamento em passos
intermedi√°rios da constru√ß√£o (como a ast n√£o vai ser montada
completamente, fazendo a liga√ß√£o entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermedi√°rios da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** D√∫vida #6

Se alguma express√£o do for possuir o operador un√°rio interroga√ß√£o (?)
ou o tern√°rio (?:), poderia isso gerar problemas de preced√™ncia n√£o
contemplados pelas regras de preced√™ncia da linguagem C? Se sim, como
devemos resolver esses problemas?
