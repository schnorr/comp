# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+TITLE: D√∫vidas da E3 do Projeto de Compilador
#+Author: Lucas Mello Schnorr
#+Date: schnorr@inf.ufrgs.br
#+Language: pt-br

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, a4paper]
#+LATEX_HEADER: \input{org-babel.tex}

#+OPTIONS: toc:nil title:nil
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* E3 2020/2
** TODO 2021-03-03 D0
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao inv√©s de C?
Precisar√≠amos mudar o main.c para main.cpp, mas isto facilitaria para
a constru√ß√£o da √°rvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma √°rvore com um n√∫mero arbitr√°rio de filhos em
cada n√≥. Podemos fazer esta altera√ß√£o?

R: Pode sim (usar C++), mas n√£o vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as fun√ß√µes em arquivos separados, cpp, que
s√£o chamadas pelo c√≥digo em C normal como est√° no main.c.
*** Pergunta #2.1

1) Precisamos colocar tipo nos tokens? Por exemplo: %token<valorReal>
   TK_LIT_FLOAT, ou somente a declara√ß√£o do valor_lexico √© suficiente? Se
   precisamos, temos como reaproveitar as defini√ß√µes do valor_lexico?
   Como far√≠amos isso?

R: Somente a declara√ß√£o do valor l√©xico √© suficiente, e recomendada de
acordo com a especifica√ß√£o. Nota que somente assim poderemos ter
acesso a uma estrutura gen√©rica que poder√° ser tratada independente de
qual √© o valor do token por tr√°s. Esse valor do token n√£o ser√°
perdido, temos descritores dentro da estrutura valor l√©xico que ser√£o
respons√°veis por diferenciar os tipos de literais, por exemplo.

*** Pergunta #2.2

2) Qual o tipo de dado de cada elemento da arvore? Seria a estrutura
   que cont√©m n√∫mero da linha, tipo e valor?

R: Cada n√≥ da √°rvore deve ser de um tipo estrutura de dados definida
pelo grupo. Tipicamente, usa-se uma estrutura de √°rvore gen√©rica
n-√°ria com um campo de usu√°rio, onde nesse campo de usu√°rio o grupo
poder√° adicionar informa√ß√µes relativas √† AST (tipo do n√≥, etc).

*** Pergunta #2.3

3) Para construirmos a arvore, pensamos em duas fun√ß√µes:

    - Uma que cria e retorna uma folha e, se a arvore esta vazia,
      atribui √† arvore esta folha

    - Uma que recebe dados e filhos, cria um nodo, insere mais um
      filho e coloca a arvore nesse filho, depois atribui √† arvore
      este novo nodo

Isto est√° correto? √â assim mesmo para construirmos a √°rvore?

R: Uma folha √© um n√≥ sem filhos, ent√£o acho improdutivo ter um n√≥ tipo
folha e um n√≥ tipo intermedi√°rio. Conforme descrito na Sec 2.2, acho
que √© importante ter fun√ß√µes de cria√ß√£o de n√≥s e adi√ß√£o de filhos. A
constru√ß√£o da √°rvore em si √© feita atrav√©s das regras do bison. Um
exemplo, como criar a AST para a regra abaixo:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um n√≥ da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Perceba o uso de $1 e $3 conforme vimos no video bison parte 2.  No
exemplo acima, apenas duas fun√ß√µes foram necess√°rias (~ast_create~ e
~ast_add_child~). Fica a crit√©rio do grupo empregar fun√ß√µes mais
sofisticadas se preferirem.

*** Pergunta #3

 Para representarmos uma express√£o tern√°ria na √°rvore sint√°tica
 abstrata, posso considerar apenas a interroga√ß√£o (?) como pai e os
 tr√™s outros operandos como filhos, ignorando os dois pontos (:)?

R: Pode. Mas veja que na pr√°tica, a interroga√ß√£o e os dois pontos s√£o
um √∫nico operador. Inclusive, chamos a aten√ß√£o para o que est√°
explicitado na Sec 2.4: "No caso do operador tern√°rio, deve ser
utilizado o nome '?:'.", mas isso apenas na sa√≠da. A tua AST pode
conter o tipo que quiser, como ~AST_TERNARY~ ou algo assim.

*** Pergunta #4

 Estou com dificuldade de entender como funciona o processo de
 constru√ß√£o da √°rvore sint√°tica quando h√° m√∫ltiplas linhas de
 c√≥digo. Em especial, como fazemos a inser√ß√£o de folhas e de nodos com
 filhos? Nodos folhas devem ser inseridas onde? Nodos com filhos devem
 tornar-se pais do resto da arvore ou seguir como filhos da raiz? Como
 sabemos qual nodo √© pai dos nodos filho?

R: Recomendo fazer um programa completo escrito na nossa linguagem e
executar o nosso compilador da seguinte forma:

#+BEGIN_EXAMPLE
./etapa3 < arquivo_com_programa_com_multiplas_linhas
#+END_EXAMPLE

Para fazer a inser√ß√£o de n√≥s e filhos, deve-se empregar totalmente os
marcadores especiais do bison para isso, atrav√©s da adi√ß√£o de c√≥digo
no final de cada regra gramatical, pois √© ele que ir√° decidir a ordem
que estes c√≥digos ser√£o criados. Por exemplo, para a regra gramatical
que envolve o reconhecimento sint√°tico da soma bin√°ria:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um n√≥ da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Neste caso acima, temos um n√≥ intermedi√°rio de soma que tem dois
filhos. N√≥s criamos um novo n√≥ da nossa AST, com o tipo ~AST_SUM~, e o
atribu√≠mos para $$, que √© o marcador especial do bison para se referir
a cabe√ßa da produ√ß√£o gramatical. Em seguida, adicionamos dois filhos,
primeiro o filho $1 e depois o filho $3 que s√£o respectivamente os
dois operandos E do corpo da produ√ß√£o. Veja que esses operandos s√£o
tamb√©m do n√£o-terminal E, ent√£o podemos sem d√∫vida assumir que os n√≥s
da AST deles j√° foram criados pela execu√ß√£o de c√≥digo associado √†s
outras regras gramaticais (inclusive essa mesma).

*** Pergunta #5

 Para representar a √°rvore, pensamos numa estrutura onde um nodo
 indica um pr√≥ximo irm√£o e um pr√≥ximo filho, ou seja, √© uma √°rvore
 cujos filhos s√£o listas encadeadas. Isto √© permitido?

R: Recomendo a leitura da Sec 2.2 da especifica√ß√£o. Em geral, eu n√£o
recomendo esse tipo de estrutura onde os irm√£os est√£o conectados pois
ela n√£o √© natural no contexto de uma AST. N√£o teremos rela√ß√£o diretas
entre irm√£os, apenas entre pai e seus filhos. Se algo preciso ser
feito entre irm√£os, √© o pai que se ocupar√°.

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os v√≠deos sobre o Bison e a especifica√ß√£o ...
... gostaria de validar se √© de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declara√ß√µes de tokens usei constru√ß√µes como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

√â desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redund√¢ncia?

*** Pergunta #2

... n√£o me parece claro como, no arquivo parser.y, teremos acesso √†
vari√°vel "arvore" declarada no arquivo main.c, para que possamos
constru√≠-la usando as a√ß√µes do parser. Ela n√£o deveria ser passada
para a fun√ß√£o yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especifica√ß√£o
  - N√≥ ~return~ da AST tem um filho, que √© uma express√£o
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especifica√ß√£o e tentando ir de acordo com os
coment√°rios no primeiro v√≠deo de d√∫vida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de c√≥digo C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso est√° causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adi√ß√£o sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Por√©m, fazendo a declara√ß√£o dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos s√≥ definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Est√° certo deixar assim?

*** Pergunta #2

N√£o entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os pr√≥prios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Voc√™ pede pra que os valores dos tokens sejam tratados de forma
correta em rela√ß√£o ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas n√£o sabemos agora
como transformar o conte√∫do do ~yytext~ em 1 √∫nico char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisar√≠amos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se peg√°ssemos o conte√∫do direto de
~yytext[1]~ j√° ter√≠amos o valor dele, j√° sem as aspas.

** DONE 2020-09-29 D2
*** D√∫vida #1

√â poss√≠vel acessar a vari√°vel yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compila√ß√£o.

*** D√∫vida #2

Na se√ß√£o 2.3, item 1, √© dito que as declara√ß√µes de fun√ß√µes devem ter
dois filhos: O primeiro comando e a pr√≥xima fun√ß√£o.

1. Isto significa, ent√£o, que n√£o devemos salvar a assinatura da
   fun√ß√£o (os par√¢metros que pode receber) como seus filhos?

2. Da mesma forma, n√£o precisamos, ent√£o, salvar a declara√ß√£o de
   vari√°veis globais na AST, visto que as fun√ß√µes apontam apenas para
   a pr√≥xima fun√ß√£o?

3. Tamb√©m relacionado a vari√°veis, nas vari√°veis locais precisamos
   colocar na AST apenas aquelas que s√£o inicializadas (e.x. int x <=
   5;) e ignorar aquelas que n√£o s√£o (e.x. int x;)?

*** D√∫vida #3

1. Na parte que fala sobre a exporta√ß√£o (impress√£o) da √Årvore, voc√™
   n√£o fala nada sobre os comandos de "input" e "output". N√£o devemos
   printar eles?

   Na parte de chamar uma fun√ß√£o, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que ser√£o separados por v√≠rgula ou algo assim) ?

*** D√∫vida #4

2. Na parte de montar a arvore, diz que n√£o devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** D√∫vida #5

3. Uma d√∫vida em rela√ß√£o a montagem da ast, por exemplo na cria√ß√£o de
   um nodo para a declara√ß√£o de fun√ß√£o, na especifica√ß√£o diz que deve
   ter pelo menos dois filhos (primeiro comando e a pr√≥xima
   fun√ß√£o).

   Sobre isso, estamos criando um nodo de fun√ß√£o que tem s√≥ um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declara√ß√£o e depois para a pr√≥xima fun√ß√£o. Queria entender se
   est√° correto fazer desta maneira, e se tem alguma implica√ß√£o na
   parte de exportar a √°rvore (se teria problema em rela√ß√£o aos
   ponteiros na corre√ß√£o).

*** D√∫vida #6

4. Na associa√ß√£o dos tokens no yylval, pensando nos caracteres
   especiais, n√£o entendi como fazemos a rela√ß√£o deles com os valores
   do parser, sendo que no parser definimos esses s√≠mbolos ('+' e '-')
   manualmente nas express√µes.

*** D√∫vida #7

Acho que tinha me confundido nessa parte do chamar a fun√ß√£o.

N√≥s vamos imprimir toda a estrutura da √°rvore em ponteiros (com suas
rela√ß√µes) e depois vamos identific√°-los com os labels, certo?

Ent√£o nesse caso da chamada de fun√ß√£o teremos o ponteiro da chamada e
depois x outros ponteiros que ser√£o os par√¢metros sendo passados? 

*** D√∫vida #8

A impress√£o do "proximo" de um comando √© feita da mesma forma que para
um filho?

*** D√∫vida #9

Gostaria de pedir tamb√©m se tens um exemplo um pouco maior de sa√≠da?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execu√ß√£o seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** D√∫vida #5

Para mim, a quest√£o do input e output ficou mais confusa ap√≥s ter sido
dito que n√£o √© necess√°rio imprimir o n√≥ desses comandos se a
especifica√ß√£o n√£o diz nada a respeito. Mas a especifica√ß√£o diz que
eles devem ter pelo menos um filho: a vari√°vel a ser lida ou
escrita. Gostaria de saber se esses comandos n√£o devem mais fazer
parte da √°rvore ou n√£o.

Resposta: output e input devem fazer parte da AST!
- Ver D√∫vida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia √† aus√™ncia de
labels para esses comandos na especifica√ß√£o. Meu pensamento inicial √©
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anota√ß√£o Prof.
- Ver "D√∫vida #3"

*** D√∫vida #1

Queria s√≥ confirmar sobre a exporta√ß√£o para os comandos "input" e
"output". No v√≠deo de d√∫vidas anterior voc√™ disse que como n√£o √©
falado no enunciado sobre a exporta√ß√£o deles n√£o precisamos
trata-los. 

Resposta Prof.: Sim, precisamos trat√°-los.

Quando diz que "n√£o precisamos", ainda seria v√°lido exportar eles?

Resposta Prof.: Totalmente v√°lido!

Como fazemos a constru√ß√£o deles na √°rvore seria mais simples exportar
junto, especialmente na impress√£o da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de sa√≠da √©
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Ent√£o, na E3:
  - N√≥ da AST =input= (label "input") tem pelo menos um filho
    - Um n√≥ identificador
  - N√≥ da AST ~output~ (label "output") tem pelo menos um filho
    - Um n√≥ identificador OU um n√≥ literal

*** D√∫vida #2 / Compartilhamento

"Script python para converter sa√≠da para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, n√≥s do grupo J fizemos um pequeno script que faz
a "tradu√ß√£o" para o formato que o dot espera. Isso facilita bastante a
corre√ß√£o das sa√≠das. Sabemos que √© um c√≥digo bem simples, mas pensamos
que pode ajudar outros grupos. Envio o c√≥digo em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a sa√≠da para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe √© que utilizando os endere√ßos originais o dot n√£o
funcionou, ent√£o mudamos os nomes para n0, n1, n2 ... nN.

O grupo n√£o garante corretude e adverte para usar com suas contas e
riscos üòÖ

*** D√∫vida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", j√° que seria necess√°rio na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma express√£o un√°ria '-' que tem o filho "int 10",

   +ou se √© necess√°rio tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** D√∫vida #4

Uma d√∫vida (ou mais uma curiosidade) sobre a libera√ß√£o de mem√≥ria. Na
avalia√ß√£o com o valgrind, precisamos apenas garantir que n√£o haver√°
leak de mem√≥ria nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto est√° dando leak, o que acredito que √© o
esperado j√° que n√£o estamos fazendo nenhum tratamento em passos
intermedi√°rios da constru√ß√£o (como a ast n√£o vai ser montada
completamente, fazendo a liga√ß√£o entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermedi√°rios da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** D√∫vida #6

Se alguma express√£o do for possuir o operador un√°rio interroga√ß√£o (?)
ou o tern√°rio (?:), poderia isso gerar problemas de preced√™ncia n√£o
contemplados pelas regras de preced√™ncia da linguagem C? Se sim, como
devemos resolver esses problemas?
